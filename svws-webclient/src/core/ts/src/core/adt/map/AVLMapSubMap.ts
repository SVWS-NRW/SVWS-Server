import { JavaMapEntry, cast_java_util_Map_Entry } from '../../../java/util/JavaMapEntry';
import { NavigableSet, cast_java_util_NavigableSet } from '../../../java/util/NavigableSet';
import { JavaSet, cast_java_util_Set } from '../../../java/util/JavaSet';
import { NavigableMap, cast_java_util_NavigableMap } from '../../../java/util/NavigableMap';
import { AVLMapSubCollection, cast_de_nrw_schule_svws_core_adt_map_AVLMapSubCollection } from '../../../core/adt/map/AVLMapSubCollection';
import { AVLMapIntervall, cast_de_nrw_schule_svws_core_adt_map_AVLMapIntervall } from '../../../core/adt/map/AVLMapIntervall';
import { AVLMapSubEntrySetIterator, cast_de_nrw_schule_svws_core_adt_map_AVLMapSubEntrySetIterator } from '../../../core/adt/map/AVLMapSubEntrySetIterator';
import { AVLMapSubKeySet, cast_de_nrw_schule_svws_core_adt_map_AVLMapSubKeySet } from '../../../core/adt/map/AVLMapSubKeySet';
import { JavaString, cast_java_lang_String } from '../../../java/lang/JavaString';
import { SortedSet, cast_java_util_SortedSet } from '../../../java/util/SortedSet';
import { AVLMap, cast_de_nrw_schule_svws_core_adt_map_AVLMap } from '../../../core/adt/map/AVLMap';
import { Comparator, cast_java_util_Comparator } from '../../../java/util/Comparator';
import { AVLMapNode, cast_de_nrw_schule_svws_core_adt_map_AVLMapNode } from '../../../core/adt/map/AVLMapNode';
import { SortedMap, cast_java_util_SortedMap } from '../../../java/util/SortedMap';
import { JavaIterator, cast_java_util_Iterator } from '../../../java/util/JavaIterator';
import { AVLMapSubKeySetIterator, cast_de_nrw_schule_svws_core_adt_map_AVLMapSubKeySetIterator } from '../../../core/adt/map/AVLMapSubKeySetIterator';
import { Collection, cast_java_util_Collection } from '../../../java/util/Collection';
import { JavaObject, cast_java_lang_Object } from '../../../java/lang/JavaObject';
import { AVLMapSubEntrySet, cast_de_nrw_schule_svws_core_adt_map_AVLMapSubEntrySet } from '../../../core/adt/map/AVLMapSubEntrySet';
import { JavaMap, cast_java_util_Map } from '../../../java/util/JavaMap';
import { Vector, cast_java_util_Vector } from '../../../java/util/Vector';
import { AVLMapSubCollectionIterator, cast_de_nrw_schule_svws_core_adt_map_AVLMapSubCollectionIterator } from '../../../core/adt/map/AVLMapSubCollectionIterator';
import { IllegalArgumentException, cast_java_lang_IllegalArgumentException } from '../../../java/lang/IllegalArgumentException';

export class AVLMapSubMap<K, V> extends JavaObject implements NavigableMap<K, V> {

	/**
	 *  Die {@link AVLMap} auf der diese Sup-Map operiert.
	 */
	private readonly _par : AVLMap<K, V>;

	/**
	 *  Das {@link AVLMapIntervall} auf das sich diese Sub-Map bezieht.
	 */
	private readonly _iv : AVLMapIntervall<K>;

	/**
	 *  Falls TRUE wird die {@link AVLMap} aufsteigend, andernfalls absteigend interpretiert.
	 */
	private _asc : boolean = false;


	/**
	 * Erstellt eine neue Sub-Map relativ zur Ã¼bergebenen {@link AVLMap}.
	 * 
	 * @param parent    Die {@link AVLMap} auf der diese Sup-Map operiert.
	 * @param intervall Das {@link AVLMapIntervall} auf das sich diese Sub-Map bezieht.
	 * @param asc       Falls TRUE wird die {@link AVLMap} aufsteigend, andernfalls absteigend interpretiert.
	 */
	constructor(parent : AVLMap<K, V>, intervall : AVLMapIntervall<K>, asc : boolean) {
		super();
		this._par = parent;
		this._iv = intervall;
		this._asc = asc;
	}

	public toString() : string {
		let s : string | null = "";
		for (let e of this.entrySet()) 
			s += (s.length === 0 ? "" : ", ") + e;
		return "Entries = [" + s! + "], iv = " + this._iv + ", asc = " + this._asc;
	}

	public equals(o : unknown) : boolean {
		if (o as unknown === this as unknown) 
			return true;
		if (((o instanceof JavaObject) && (o.isTranspiledInstanceOf('java.util.Map'))) === false) 
			return false;
		let mapO : JavaMap<unknown, unknown> | null = cast_java_util_Map(o);
		if (mapO.size() !== this.size()) 
			return false;
		for (let e of this.entrySet()) 
			if (JavaObject.equalsTranspiler(e.getValue(), (mapO.get(e.getKey()))) === false) 
				return false;
		return true;
	}

	public hashCode() : number {
		let h : number = 0;
		for (let entry of this.entrySet()) 
			h += JavaObject.getTranspilerHashCode(entry);
		return h;
	}

	public comparator() : Comparator<K> {
		return this._par.bcGetComparator(this._iv);
	}

	public firstKey() : K {
		return this._asc ? this._par.bcGetFirstKeyOrException(this._iv) : this._par.bcGetLastKeyOrException(this._iv);
	}

	public lastKey() : K {
		return this._asc ? this._par.bcGetLastKeyOrException(this._iv) : this._par.bcGetFirstKeyOrException(this._iv);
	}

	public keySet() : JavaSet<K> {
		return new AVLMapSubKeySet(this);
	}

	public values() : Collection<V> {
		return new AVLMapSubCollection(this);
	}

	public entrySet() : JavaSet<JavaMapEntry<K, V>> {
		return new AVLMapSubEntrySet(this);
	}

	public size() : number {
		return this._par.bcGetSize(this._iv);
	}

	public isEmpty() : boolean {
		return this._par.bcIsEmpty(this._iv);
	}

	public containsKey(key : unknown) : boolean {
		return this._par.bcContainsKey(key, this._iv);
	}

	public containsValue(value : unknown) : boolean {
		return this._par.bcContainsValue(value, this._iv);
	}

	public get(key : unknown) : V | null {
		return this._par.bcGetValueOfKeyOrNull(key, this._iv);
	}

	public put(key : K, value : V) : V | null {
		return this._par.bcAddEntryReturnOldValueOrNull(key, value, this._iv);
	}

	public remove(key : unknown) : V | null {
		return this._par.bcRemoveKeyReturnOldValueOrNull(key, this._iv);
	}

	public putAll(map : JavaMap<K, V>) : void {
		this._par.bcAddAllEntriesOfMap(map, this._iv);
	}

	public clear() : void {
		let iter : JavaIterator<JavaMapEntry<K | null, V | null> | null> | null = this.bcGetSubEntrySetIterator();
		while (iter.hasNext()) {
			iter.next();
			iter.remove();
		}
	}

	public lowerEntry(key : K) : JavaMapEntry<K, V> | null {
		return this._asc ? this._par.bcGetLowerEntryOrNull(key, this._iv) : this._par.bcGetHigherEntryOrNull(key, this._iv);
	}

	public lowerKey(key : K) : K | null {
		return this._asc ? this._par.bcGetLowerKeyOrNull(key, this._iv) : this._par.bcGetHigherKeyOrNull(key, this._iv);
	}

	public floorEntry(key : K) : JavaMapEntry<K, V> | null {
		return this._asc ? this._par.bcGetFloorEntryOrNull(key, this._iv) : this._par.bcGetCeilingEntryOrNull(key, this._iv);
	}

	public floorKey(key : K) : K | null {
		return this._asc ? this._par.bcGetFloorKeyOrNull(key, this._iv) : this._par.bcGetCeilingKeyOrNull(key, this._iv);
	}

	public ceilingEntry(key : K) : JavaMapEntry<K, V> | null {
		return this._asc ? this._par.bcGetCeilingEntryOrNull(key, this._iv) : this._par.bcGetFloorEntryOrNull(key, this._iv);
	}

	public ceilingKey(key : K) : K | null {
		return this._asc ? this._par.bcGetCeilingKeyOrNull(key, this._iv) : this._par.bcGetFloorKeyOrNull(key, this._iv);
	}

	public higherEntry(key : K) : JavaMapEntry<K, V> | null {
		return this._asc ? this._par.bcGetHigherEntryOrNull(key, this._iv) : this._par.bcGetLowerEntryOrNull(key, this._iv);
	}

	public higherKey(key : K) : K | null {
		return this._asc ? this._par.bcGetHigherKeyOrNull(key, this._iv) : this._par.bcGetLowerKeyOrNull(key, this._iv);
	}

	public firstEntry() : JavaMapEntry<K, V> | null {
		return this._asc ? this._par.bcGetFirstEntryOrNull(this._iv) : this._par.bcGetLastEntryOrNull(this._iv);
	}

	public lastEntry() : JavaMapEntry<K, V> | null {
		return this._asc ? this._par.bcGetLastEntryOrNull(this._iv) : this._par.bcGetFirstEntryOrNull(this._iv);
	}

	public pollFirstEntry() : JavaMapEntry<K, V> | null {
		return this._asc ? this._par.bcPollFirstEntryOrNull(this._iv) : this._par.bcPollLastEntryOrNull(this._iv);
	}

	public pollLastEntry() : JavaMapEntry<K, V> | null {
		return this._asc ? this._par.bcPollLastEntryOrNull(this._iv) : this._par.bcPollFirstEntryOrNull(this._iv);
	}

	public descendingMap() : NavigableMap<K, V> {
		return new AVLMapSubMap(this._par, this._iv, !this._asc);
	}

	public navigableKeySet() : NavigableSet<K> {
		return new AVLMapSubKeySet(this);
	}

	public descendingKeySet() : NavigableSet<K> {
		return new AVLMapSubKeySet(new AVLMapSubMap(this._par, this._iv, !this._asc));
	}

	public subMap(fromKey : K, fromInclusive : boolean, toKey : K, toInclusive : boolean) : NavigableMap<K, V>;

	public subMap(fromKey : K, toKey : K) : SortedMap<K, V>;

	/**
	 * Implementation for method overloads of 'subMap'
	 */
	public subMap(__param0 : K, __param1 : K | boolean, __param2? : K, __param3? : boolean) : NavigableMap<K, V> | SortedMap<K, V> {
		if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && ((typeof __param1 !== "undefined") && typeof __param1 === "boolean") && ((typeof __param2 !== "undefined") && (typeof __param2 !== "undefined")) && ((typeof __param3 !== "undefined") && typeof __param3 === "boolean")) {
			let fromKey : K = __param0 as unknown as K;
			let fromInclusive : boolean = __param1 as boolean;
			let toKey : K = __param2 as unknown as K;
			let toInclusive : boolean = __param3 as boolean;
			return this._createMap(fromKey, fromInclusive, toKey, toInclusive, this._asc);
		} else if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && ((typeof __param1 !== "undefined") && (typeof __param1 !== "undefined")) && (typeof __param2 === "undefined") && (typeof __param3 === "undefined")) {
			let fromKey : K = __param0 as unknown as K;
			let toKey : K = __param1 as unknown as K;
			return this._createMap(fromKey, true, toKey, false, this._asc);
		} else throw new Error('invalid method overload');
	}

	public headMap(toKey : K, inclusive : boolean) : NavigableMap<K, V>;

	public headMap(toKey : K) : SortedMap<K, V>;

	/**
	 * Implementation for method overloads of 'headMap'
	 */
	public headMap(__param0 : K, __param1? : boolean) : NavigableMap<K, V> | SortedMap<K, V> {
		if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && ((typeof __param1 !== "undefined") && typeof __param1 === "boolean")) {
			let toKey : K = __param0 as unknown as K;
			let inclusive : boolean = __param1 as boolean;
			return this._createMap(this._iv.from, this._iv.fromInc, toKey, inclusive, this._asc);
		} else if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && (typeof __param1 === "undefined")) {
			let toKey : K = __param0 as unknown as K;
			return this._createMap(this._iv.from, this._iv.fromInc, toKey, false, this._asc);
		} else throw new Error('invalid method overload');
	}

	public tailMap(fromKey : K, inclusive : boolean) : NavigableMap<K, V>;

	public tailMap(fromKey : K) : SortedMap<K, V>;

	/**
	 * Implementation for method overloads of 'tailMap'
	 */
	public tailMap(__param0 : K, __param1? : boolean) : NavigableMap<K, V> | SortedMap<K, V> {
		if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && ((typeof __param1 !== "undefined") && typeof __param1 === "boolean")) {
			let fromKey : K = __param0 as unknown as K;
			let inclusive : boolean = __param1 as boolean;
			return this._createMap(fromKey, inclusive, this._iv.to, this._iv.toInc, this._asc);
		} else if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && (typeof __param1 === "undefined")) {
			let fromKey : K = __param0 as unknown as K;
			return this._createMap(fromKey, true, this._iv.to, this._iv.toInc, this._asc);
		} else throw new Error('invalid method overload');
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#add(Object)}. FÃ¼gt einen SchlÃ¼ssel (Key) dieser Datenstruktur hinzu.
	 * 
	 * @param e Der einzufÃ¼gende SchlÃ¼ssel (Key).
	 * 
	 * @return TRUE, falls der SchlÃ¼ssel (Key) noch nicht existierte, sonst FALSE.
	 */
	bcAddKey(e : K) : boolean {
		return this._par.bcAddKey(e, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#addAll(Collection)}. FÃ¼gt alle SchlÃ¼ssel (Keys) der Collection dieser
	 * Datenstruktur hinzu.
	 * 
	 * @param c Die Collection mit den einzufÃ¼genden SchlÃ¼sseln (Keys).
	 * 
	 * @return TRUE, falls mindestens ein SchlÃ¼ssel (Key) noch nicht existierte und somit hinzugefÃ¼gt wurde.
	 */
	bcAddAllKeys(c : Collection<K>) : boolean {
		return this._par.bcAddAllKeys(c, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubEntrySet#add(java.util.Map.Entry)}. FÃ¼gt ein Entry der Datenstruktur hinzu.
	 * 
	 * @param e Das einzufÃ¼gende Entry.
	 * 
	 * @return TRUE, falls das Entry (e.getKey(), e.getValue()) neu war und somit hinzugefÃ¼gt wurde.
	 */
	bcAddEntryReturnBool(e : JavaMapEntry<K, V>) : boolean {
		return this._par.bcAddEntryReturnBool(e, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubEntrySet#addAll(Collection)}. FÃ¼gt alle Entries der Collection dieser
	 * Datenstruktur hinzu.
	 * 
	 * @param c Die Collection mit den einzufÃ¼genden Entries.
	 * 
	 * @return TRUE, falls mindestens ein Entry neu war und somit hinzugefÃ¼gt wurde.
	 */
	bcAddAllEntries(c : Collection<JavaMapEntry<K, V>>) : boolean {
		return this._par.bcAddAllEntries(c, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#containsAll(Collection)}. ÃberprÃ¼ft, ob alle SchlÃ¼ssel (Keys) der
	 * Collection in dieser Datenstruktur existieren.
	 * 
	 * @param c Die Collection mit allen SchlÃ¼sseln (Keys) welche Ã¼berprÃ¼ft werden sollen.
	 * 
	 * @return TRUE, falls alle SchlÃ¼ssel (Keys) der Collection in dieser Datenstruktur existieren.
	 */
	bcContainsAllKeys(c : Collection<unknown>) : boolean {
		return this._par.bcContainsAllKeys(c, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubEntrySet#contains(Object)}. ÃberprÃ¼ft, ob das Ã¼bergebene Entry in dieser
	 * Datenstruktur existiert.
	 * 
	 * @param o Das Entry (SchlÃ¼ssel-Wert-Paar) nach dem gesucht wird.
	 * 
	 * @return TRUE, falls das Ã¼bergebene Entry bereits in dieser Datenstruktur existiert.
	 */
	bcContainsEntry(o : unknown) : boolean {
		return this._par.bcContainsEntry(o, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubEntrySet#containsAll(Collection)}. ÃberprÃ¼ft, ob alle Entries der Collection
	 * in dieser Datenstruktur existieren.
	 * 
	 * @param c Die Collection mit den Entries welche Ã¼berprÃ¼ft werden sollen.
	 * 
	 * @return TRUE, falls alle Entries in dieser Datenstruktur existieren.
	 */
	bcContainsAllEntries(c : Collection<unknown>) : boolean {
		return this._par.bcContainsAllEntries(c, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubCollection#containsAll(Collection)}. ÃberprÃ¼ft, ob alle Werte (Values) aus
	 * der Collection in dieser Datenstruktur vorkommen. Diese Methode sollte NICHT verwendet werden, da sie
	 * quadratische Laufzeit hat.
	 * 
	 * @param c Die Collection deren Werte (Values) Ã¼berprÃ¼ft werden sollen.
	 * 
	 * @return TRUE, falls alle Werte (Values) der Collection in dieser Datenstruktur existieren.
	 * 
	 */
	bcContainsAllValues(c : Collection<unknown>) : boolean {
		return this._par.bcContainsAllValues(c, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#remove(Object)}. Entfernt einen SchlÃ¼ssel (Key) aus dieser
	 * Datenstruktur.
	 * 
	 * @param o Der SchlÃ¼ssel (Key) der entfernt werden soll.
	 * 
	 * @return TRUE, falls der SchlÃ¼ssel existierte und somit entfernt wurde.
	 */
	bcRemoveKeyReturnBool(o : unknown) : boolean {
		return this._par.bcRemoveKeyReturnBool(o, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#removeAll(Collection)}. Entfernt alle SchlÃ¼ssel (Keys) aus dieser
	 * Datenstruktur.
	 * 
	 * @param c Die Collection mit allen SchlÃ¼sseln (Keys) die entfernt werden sollen.
	 * 
	 * @return TRUE, falls mindestens ein SchlÃ¼ssel (Key) entfernt wurde.
	 */
	bcRemoveAllKeys(c : Collection<unknown>) : boolean {
		return this._par.bcRemoveAllKeys(c, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubEntrySet#remove(Object)}. Entfernt das Entry aus dieser Datenstruktur.
	 * 
	 * @param o Das Entry, welches entfernt werden soll.
	 * 
	 * @return TRUE, falls das Entry in der Datenstruktur existierte und somit entfernt wurde.
	 */
	bcRemoveEntry(o : unknown) : boolean {
		return this._par.bcRemoveEntry(o, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubEntrySet#removeAll(Collection)}. Entfernt alle Entries der Collection aus
	 * dieser Datenstruktur.
	 * 
	 * @param c Die Collection mit den Entries, welche entfernt werden sollen.
	 * 
	 * @return TRUE, falls mindestens ein Entry entfernt wurde.
	 */
	bcRemoveAllEntries(c : Collection<unknown>) : boolean {
		return this._par.bcRemoveAllEntries(c, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#pollFirst()}. Entfernt und liefert den ersten SchlÃ¼ssel (Key) dieser
	 * Datenstruktur. Dabei wird beachtet, ob diese Sub-Map aufsteigend oder absteigend zu interpretieren ist.
	 * 
	 * @return Entfernt und liefert den ersten SchlÃ¼ssel (Key) dieser Datenstruktur falls vorhanden, andernfalls NULL.
	 */
	bcPollFirstKeyOrNull() : K | null {
		return this._asc ? this._par.bcPollFirstKeyOrNull(this._iv) : this._par.bcPollLastKeyOrNull(this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#pollLast()}. Entfernt und liefert den letzten SchlÃ¼ssel (Key) dieser
	 * Datenstruktur. Dabei wird beachtet, ob diese Sub-Map aufsteigend oder absteigend zu interpretieren ist.
	 * 
	 * @return Entfernt und liefert den letzten SchlÃ¼ssel (Key) dieser Datenstruktur falls vorhanden, andernfalls NULL.
	 */
	bcPollLastKeyOrNull() : K | null {
		return this._asc ? this._par.bcPollLastKeyOrNull(this._iv) : this._par.bcPollFirstKeyOrNull(this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#retainAll(Collection)}. Entfernt alle SchlÃ¼ssel (Keys) aus dieser
	 * Datenstruktur, auÃer sie sind in der Collection enthalten.
	 * 
	 * @param c Die Collection deren SchlÃ¼ssel (Keys) nicht entfernt werden dÃ¼rfen.
	 * 
	 * @return TRUE, falls mindestens ein SchlÃ¼ssel (Key) entfernt wurde.
	 */
	bcRetainAllKeys(c : Collection<unknown>) : boolean {
		let mapRetain : AVLMap<K, K> = new AVLMap();
		for (let obj of c) {
			let key : K = obj as unknown as K;
			mapRetain.put(key, key);
		}
		let changed : boolean = false;
		let iterOfKeys : JavaIterator<K | null> | null = this.bcGetSubKeySetIterator();
		while (iterOfKeys.hasNext()) {
			let key : K | null = iterOfKeys.next();
			if (mapRetain.containsKey(key) === false) {
				iterOfKeys.remove();
				changed = true;
			}
		}
		return changed;
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubEntrySet#retainAll(Collection)}. Entfernt alle Entries aus dieser
	 * Datenstruktur, auÃer sie sind in der Collection enthalten.
	 * 
	 * @param c Die Collection deren Entries nicht entfernt werden dÃ¼rfen.
	 * 
	 * @return TRUE, falls mindestens ein Entry entfernt wurde.
	 */
	bcRetainAllEntries(c : Collection<unknown>) : boolean {
		let mapSave : AVLMap<K, V> = new AVLMap();
		let setSave : JavaSet<JavaMapEntry<K, V>> = mapSave.entrySet();
		for (let o of c) 
			if (this._par.bcContainsEntry(o, this._iv)) 
				setSave.add(cast_java_util_Map_Entry(o));
		let changed : boolean = false;
		let iterOfEntries : JavaIterator<JavaMapEntry<K | null, V | null> | null> | null = this.bcGetSubEntrySetIterator();
		while (iterOfEntries.hasNext()) 
			if (setSave.contains(iterOfEntries.next()) === false) {
				iterOfEntries.remove();
				changed = true;
			}
		return changed;
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubCollectionIterator} und {@link AVLMapSubKeySetIterator}. Liefert das erste
	 * Entry als {@link AVLMapNode}, um Ã¼ber diese Datenstruktur zu iterieren. Dabei wird beachtet, ob diese Sub-Map
	 * aufsteigend oder absteigend zu interpretieren ist.
	 * 
	 * @return Das erste Entry als {@link AVLMapNode} dieser Datenstruktur.
	 */
	bcGetFirstEntryAsNode() : AVLMapNode<K, V> | null {
		return this._asc ? this._par.bcGetFirstEntryOrNull(this._iv) : this._par.bcGetLastEntryOrNull(this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubCollectionIterator} und {@link AVLMapSubKeySetIterator}. Liefert das nÃ¤chste
	 * Entry relativ zu einem Ã¼bergebenen Entry. Dabei wird beachtet, ob diese Sub-Map aufsteigend oder absteigend zu
	 * interpretieren ist.
	 * 
	 * @param node Das Entry dessen Nachfolger verlangt wird.
	 * 
	 * @return Das nÃ¤chste Entry relativ zu einem Ã¼bergebenen Entry.
	 */
	bcGetNextEntryOrNull(node : AVLMapNode<K, V>) : AVLMapNode<K, V> | null {
		return this._asc ? this._par.bcGetNextEntryOrNull(node, this._iv) : this._par.bcGetPrevEntryOrNull(node, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#floor(Object)}. Liefert den grÃ¶Ãten SchlÃ¼ssel (Key) welcher kleiner
	 * oder gleich dem Ã¼bergebenen SchlÃ¼ssel (Key) ist. Somit der selbe SchlÃ¼ssel (Key) falls vorhanden, andernfalls den
	 * VorgÃ¤nger-SchlÃ¼ssel (Key) falls vorhanden, andernfalls NULL. Dabei wird beachtet, ob diese Sub-Map aufsteigend
	 * oder absteigend zu interpretieren ist.
	 * 
	 * @param e Der SchlÃ¼ssel (Key) der gesucht wird bzw. sein VorgÃ¤nger-SchlÃ¼ssel.
	 * 
	 * @return Den selben SchlÃ¼ssel (Key) falls vorhanden, andernfalls sein VorgÃ¤nger-SchlÃ¼ssel falls vorhanden,
	 *         andernfalls NULL.
	 */
	bcGetFloorKeyOrNull(e : K) : K | null {
		return this._asc ? this._par.bcGetFloorKeyOrNull(e, this._iv) : this._par.bcGetCeilingKeyOrNull(e, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#ceiling(Object)}. Liefert den kleinsten SchlÃ¼ssel (Key) welcher grÃ¶Ãer
	 * oder gleich dem Ã¼bergebenen SchlÃ¼ssel (Key) ist. Somit der selbe SchlÃ¼ssel (Key) falls vorhanden, andernfalls
	 * sein Nachfolger-SchlÃ¼ssel (Key) falls vorhanden, andernfalls NULL. Dabei wird beachtet, ob diese Sub-Map
	 * aufsteigend oder absteigend zu interpretieren ist.
	 * 
	 * @param e Der SchlÃ¼ssel (Key) der gesucht wird bzw. sein Nachfolger-SchlÃ¼ssel.
	 * 
	 * @return Den selben SchlÃ¼ssel (Key) falls vorhanden, andernfalls sein Nachfolger-SchlÃ¼ssel falls vorhanden,
	 *         andernfalls NULL.
	 */
	bcGetCeilingKeyOrNull(e : K) : K | null {
		return this._asc ? this._par.bcGetCeilingKeyOrNull(e, this._iv) : this._par.bcGetFloorKeyOrNull(e, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#lower(Object)}. Liefert den grÃ¶Ãten SchlÃ¼ssel (Key) welcher kleiner
	 * ist als der Ã¼bergebene SchlÃ¼ssel (Key), somit den VorgÃ¤nger-SchlÃ¼ssel des SchlÃ¼ssels (Key). Dabei wird beachtet,
	 * ob diese Sub-Map aufsteigend oder absteigend zu interpretieren ist.
	 * 
	 * @param e Der SchlÃ¼ssel (Key) dessen VorgÃ¤nger gesucht wird.
	 * 
	 * @return Den VorgÃ¤nger-SchlÃ¼ssel des Ã¼bergebenen SchlÃ¼ssels (Key) falls vorhanden, sonst NULL.
	 */
	bcGetLowerKeyOrNull(e : K) : K | null {
		return this._asc ? this._par.bcGetLowerKeyOrNull(e, this._iv) : this._par.bcGetHigherKeyOrNull(e, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#higher(Object)}. Liefert den kleinsten SchlÃ¼ssel (Key) welcher grÃ¶Ãer
	 * ist als der Ã¼bergebene SchlÃ¼ssel (Key), somit den Nachfolger-SchlÃ¼ssel des Ã¼bergebenen SchlÃ¼ssels (Key). Dabei
	 * wird beachtet, ob diese Sub-Map aufsteigend oder absteigend zu interpretieren ist.
	 * 
	 * @param e Der SchlÃ¼ssel (Key) dessen Nachfolger-SchlÃ¼ssel gesucht wird.
	 * 
	 * @return Den Nachfolger-SchlÃ¼ssel des Ã¼bergebenen SchlÃ¼ssels (Key) falls vorhanden, sonst NULL.
	 */
	bcGetHigherKeyOrNull(e : K) : K | null {
		return this._asc ? this._par.bcGetHigherKeyOrNull(e, this._iv) : this._par.bcGetLowerKeyOrNull(e, this._iv);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#toArray()} und {@link AVLMapSubKeySet#toArray(Object[])}. Liefert
	 * einen {@link Vector} der alle SchlÃ¼ssel (Keys) dieser Sub-Map beinhaltet.
	 * 
	 * @return Ein {@link Vector} der alle SchlÃ¼ssel (Keys) dieser Sub-Map beinhaltet.
	 */
	bcGetVectorOfKeys() : Vector<K | null> {
		let v : Vector<K | null> | null = new Vector();
		let iter : JavaIterator<K | null> | null = this.navigableKeySet().iterator();
		while (iter.hasNext()) 
			v.add(iter.next());
		return v;
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubCollection#toArray()} und {@link AVLMapSubCollection#toArray(Object[])}.
	 * Liefert einen {@link Vector} der alle Werte (Values) dieser Sub-Map beinhaltet.
	 * 
	 * @return Ein {@link Vector} der alle Werte (Values) dieser Sub-Map beinhaltet.
	 */
	bcGetVectorOfValues() : Vector<V | null> {
		let v : Vector<V | null> | null = new Vector();
		let iter : JavaIterator<V | null> | null = this.values().iterator();
		while (iter.hasNext()) 
			v.add(iter.next());
		return v;
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubEntrySet#toArray()} und {@link AVLMapSubEntrySet#toArray(Object[])}. Liefert
	 * einen {@link Vector} der alle Entries dieser Sub-Map beinhaltet.
	 * 
	 * @return Ein {@link Vector} der alle Entries dieser Sub-Map beinhaltet.
	 */
	bcGetVectorOfEntries() : Vector<JavaMapEntry<K | null, V | null> | null> {
		let v : Vector<JavaMapEntry<K | null, V | null> | null> | null = new Vector();
		let iter : JavaIterator<JavaMapEntry<K | null, V | null> | null> | null = this.entrySet().iterator();
		while (iter.hasNext()) 
			v.add(iter.next());
		return v;
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubKeySet#iterator()}. Liefert einen {@link Iterator} von SchlÃ¼sseln (Keys)
	 * relativ zu dieser Sub-Map.
	 * 
	 * @return Einen {@link Iterator} von SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 */
	bcGetSubKeySetIterator() : JavaIterator<K> {
		return new AVLMapSubKeySetIterator(this);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubCollection#iterator()}. Liefert einen {@link Iterator} von Werten (Values)
	 * relativ zu dieser Sub-Map.
	 * 
	 * @return Einen {@link Iterator} von Werten (Values) relativ zu dieser Sub-Map.
	 */
	bcGetSubCollectionIterator() : JavaIterator<V> {
		return new AVLMapSubCollectionIterator(this);
	}

	/**
	 * Wird aufgerufen von {@link AVLMapSubEntrySet#iterator()}. Liefert einen {@link Iterator} von Entries relativ zu
	 * dieser Sub-Map.
	 * 
	 * @return Ein {@link Iterator} von Entries relativ zu dieser Sub-Map.
	 */
	bcGetSubEntrySetIterator() : JavaIterator<JavaMapEntry<K, V>> {
		return new AVLMapSubEntrySetIterator(this);
	}

	/**
	 * Wird aufgerufen und von {@link AVLMapSubKeySet#descendingSet()}. Liefert ein {@link NavigableSet} von SchlÃ¼sseln
	 * (Keys) relativ zu dieser <strong>absteigenden</strong> Sub-Map.
	 * 
	 * @return Ein {@link NavigableSet} von SchlÃ¼sseln (Keys) relativ zu dieser <strong>absteigenden</strong> Sub-Map.
	 */
	bcGetSubKeySetDescending() : NavigableSet<K> {
		return new AVLMapSubKeySet(new AVLMapSubMap(this._par, this._iv, !this._asc));
	}

	/**
	 * Wird aufgerufen und von {@link AVLMapSubKeySet#descendingIterator()}. Liefert einen {@link Iterator} von
	 * SchlÃ¼sseln (Keys) relativ zu dieser <strong>absteigenden</strong> Sub-Map.
	 * 
	 * @return Ein {@link Iterator} von SchlÃ¼sseln (Keys) relativ zu dieser <strong>absteigenden</strong> Sub-Map.
	 */
	bcGetSubKeySetDescendingIterator() : JavaIterator<K> {
		return new AVLMapSubKeySetIterator(new AVLMapSubMap(this._par, this._iv, !this._asc));
	}

	/**
	 * Wird aufgerufen und von {@link AVLMapSubKeySet#subSet(Object, boolean, Object, boolean)}. Liefert ein
	 * {@link NavigableSet} von SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 * 
	 * @param fromElement   Die linke (von) Intervallsgrenze.
	 * @param fromInclusive Gibt an, ob die linke (von) Intervallsgrenze inklusive ist.
	 * @param toElement     Die rechte (bis) Intervallsgrenze.
	 * @param toInclusive   Gibt an, ob die rechte (bis) Intervallsgrenze inklusive ist.
	 * 
	 * @return Ein {@link NavigableSet} von SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 */
	public bcGetSubKeySet(fromElement : K, fromInclusive : boolean, toElement : K, toInclusive : boolean) : NavigableSet<K>;

	/**
	 * Wird aufgerufen und von {@link AVLMapSubKeySet#subSet(Object, Object)}. Liefert ein {@link NavigableSet} von
	 * SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 * 
	 * Ãquivalent zu {@link #bcGetSubKeySet(Object, boolean, Object, boolean)} mit den Werten (fromElement, true,
	 * toElement, false).
	 * 
	 * @param fromElement Die linke (von) Intervallsgrenze <strong>inklusive</strong>.
	 * @param toElement   Die rechte (bis) Intervallsgrenze <strong>exklusive</strong>.
	 * 
	 * @return Ein {@link NavigableSet} von SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 */
	public bcGetSubKeySet(fromElement : K, toElement : K) : SortedSet<K>;

	/**
	 * Implementation for method overloads of 'bcGetSubKeySet'
	 */
	public bcGetSubKeySet(__param0 : K, __param1 : K | boolean, __param2? : K, __param3? : boolean) : NavigableSet<K> | SortedSet<K> {
		if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && ((typeof __param1 !== "undefined") && typeof __param1 === "boolean") && ((typeof __param2 !== "undefined") && (typeof __param2 !== "undefined")) && ((typeof __param3 !== "undefined") && typeof __param3 === "boolean")) {
			let fromElement : K = __param0 as unknown as K;
			let fromInclusive : boolean = __param1 as boolean;
			let toElement : K = __param2 as unknown as K;
			let toInclusive : boolean = __param3 as boolean;
			return this._createSet(fromElement, fromInclusive, toElement, toInclusive, this._asc);
		} else if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && ((typeof __param1 !== "undefined") && (typeof __param1 !== "undefined")) && (typeof __param2 === "undefined") && (typeof __param3 === "undefined")) {
			let fromElement : K = __param0 as unknown as K;
			let toElement : K = __param1 as unknown as K;
			return this._createSet(fromElement, true, toElement, false, this._asc);
		} else throw new Error('invalid method overload');
	}

	/**
	 * Wird aufgerufen und von {@link AVLMapSubKeySet#headSet(Object, boolean)}. Liefert ein {@link NavigableSet} von
	 * SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 * 
	 * @param toElement Die rechte (bis) Intervallsgrenze.
	 * @param inclusive Gibt an, ob die rechte (bis) Intervallsgrenze inklusive ist.
	 * 
	 * @return Ein {@link NavigableSet} von SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 */
	public bcGetSubKeyHeadSet(toElement : K, inclusive : boolean) : NavigableSet<K>;

	/**
	 * Wird aufgerufen und von {@link AVLMapSubKeySet#headSet(Object)}. Liefert ein {@link NavigableSet} von SchlÃ¼sseln
	 * (Keys) relativ zu dieser Sub-Map.
	 * 
	 * Ãquivalent zu {@link #bcGetSubKeyHeadSet(Object, boolean)} mit den Werten (toElement, false).
	 * 
	 * @param toElement Die rechte (bis) Intervallsgrenze <strong>exklusive</strong>.
	 * 
	 * @return Ein {@link NavigableSet} von SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 */
	public bcGetSubKeyHeadSet(toElement : K) : SortedSet<K>;

	/**
	 * Implementation for method overloads of 'bcGetSubKeyHeadSet'
	 */
	public bcGetSubKeyHeadSet(__param0 : K, __param1? : boolean) : NavigableSet<K> | SortedSet<K> {
		if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && ((typeof __param1 !== "undefined") && typeof __param1 === "boolean")) {
			let toElement : K = __param0 as unknown as K;
			let inclusive : boolean = __param1 as boolean;
			return this._createSet(this._iv.from, this._iv.fromInc, toElement, inclusive, this._asc);
		} else if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && (typeof __param1 === "undefined")) {
			let toElement : K = __param0 as unknown as K;
			return this._createSet(this._iv.from, this._iv.fromInc, toElement, false, this._asc);
		} else throw new Error('invalid method overload');
	}

	/**
	 * Wird aufgerufen und von {@link AVLMapSubKeySet#tailSet(Object, boolean)}. Liefert ein {@link NavigableSet} von
	 * SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 * 
	 * @param fromElement Die linke (von) Intervallsgrenze.
	 * @param inclusive   Gibt an, ob die linke (von) Intervallsgrenze inklusive ist.
	 * 
	 * @return Ein {@link NavigableSet} von SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 */
	public bcGetSubKeyTailSet(fromElement : K, inclusive : boolean) : NavigableSet<K>;

	/**
	 * Wird aufgerufen und von {@link AVLMapSubKeySet#tailSet(Object)}. Liefert ein {@link NavigableSet} von SchlÃ¼sseln
	 * (Keys) relativ zu dieser Sub-Map.
	 * 
	 * Ãquivalent zu {@link #bcGetSubKeyTailSet(Object, boolean)} mit den Werten (fromElement, true).
	 * 
	 * @param fromElement Die linke (von) Intervallsgrenze <strong>inklusive</strong>.
	 * 
	 * @return Ein {@link NavigableSet} von SchlÃ¼sseln (Keys) relativ zu dieser Sub-Map.
	 */
	public bcGetSubKeyTailSet(fromElement : K) : SortedSet<K>;

	/**
	 * Implementation for method overloads of 'bcGetSubKeyTailSet'
	 */
	public bcGetSubKeyTailSet(__param0 : K, __param1? : boolean) : NavigableSet<K> | SortedSet<K> {
		if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && ((typeof __param1 !== "undefined") && typeof __param1 === "boolean")) {
			let fromElement : K = __param0 as unknown as K;
			let inclusive : boolean = __param1 as boolean;
			return this._createSet(fromElement, inclusive, this._iv.to, this._iv.toInc, this._asc);
		} else if (((typeof __param0 !== "undefined") && (typeof __param0 !== "undefined")) && (typeof __param1 === "undefined")) {
			let fromElement : K = __param0 as unknown as K;
			return this._createSet(fromElement, true, this._iv.to, this._iv.toInc, this._asc);
		} else throw new Error('invalid method overload');
	}

	private _createMap(from : K, fromInc : boolean, to : K, toInc : boolean, asc : boolean) : AVLMapSubMap<K, V> {
		if (this._par.bcCheckOutOfIntervall(from, fromInc, this._iv)) 
			throw new IllegalArgumentException("FROM-KEY " + from + "/" + fromInc + " nicht in " + this._iv)
		if (this._par.bcCheckOutOfIntervall(to, toInc, this._iv)) 
			throw new IllegalArgumentException("TO-KEY " + to + "/" + toInc + " nicht in " + this._iv)
		return new AVLMapSubMap(this._par, new AVLMapIntervall(from, fromInc, to, toInc), asc);
	}

	private _createSet(from : K, fromInc : boolean, to : K, toInc : boolean, asc : boolean) : AVLMapSubKeySet<K, V> {
		return new AVLMapSubKeySet(this._createMap(from, fromInc, to, toInc, asc));
	}

	isTranspiledInstanceOf(name : string): boolean {
		return ['java.util.Map', 'java.util.NavigableMap', 'de.nrw.schule.svws.core.adt.map.AVLMapSubMap', 'java.util.SortedMap'].includes(name);
	}

}

export function cast_de_nrw_schule_svws_core_adt_map_AVLMapSubMap<K, V>(obj : unknown) : AVLMapSubMap<K, V> {
	return obj as AVLMapSubMap<K, V>;
}
