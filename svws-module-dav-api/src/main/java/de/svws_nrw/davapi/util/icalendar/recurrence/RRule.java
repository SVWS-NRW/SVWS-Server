package de.svws_nrw.davapi.util.icalendar.recurrence;

import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import de.svws_nrw.davapi.util.icalendar.DateTimeUtil;
import de.svws_nrw.davapi.util.icalendar.IProperty;
import de.svws_nrw.davapi.util.icalendar.PropertyKeys;
import de.svws_nrw.davapi.util.icalendar.VCalendar;

/**
 * Diese Klasse repräsentiert eine Regel für wiederkehrende Ereignisse gemäß
 * <a href="https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10">RFC
 * 5545</a> <br>
 * <code>
Description:  This value type is a structured value consisting of a<br>
      list of one or more recurrence grammar parts.  Each rule part is<br>
      defined by a NAME=VALUE pair.  The rule parts are separated from<br>
      each other by the SEMICOLON character.  The rule parts are not<br>
      ordered in any particular sequence.  Individual rule parts MUST<br>
      only be specified once.  Compliant applications MUST accept rule<br>
      parts ordered in any sequence, but to ensure backward<br>
      compatibility with applications that pre-date this revision of<br>
      iCalendar the FREQ rule part MUST be the first rule part specified<br>
      in a RECUR value.<br>
<br>
      The FREQ rule part identifies the type of recurrence rule.  This<br>
      rule part MUST be specified in the recurrence rule.  Valid values<br>
      include SECONDLY, to specify repeating events based on an interval<br>
      of a second or more; MINUTELY, to specify repeating events based<br>
      on an interval of a minute or more; HOURLY, to specify repeating<br>
      events based on an interval of an hour or more; DAILY, to specify<br>
      repeating events based on an interval of a day or more; WEEKLY, to<br>
      specify repeating events based on an interval of a week or more;<br>
      MONTHLY, to specify repeating events based on an interval of a<br>
      month or more; and YEARLY, to specify repeating events based on an<br>
      interval of a year or more.<br>
      <br>
      The INTERVAL rule part contains a positive integer representing at<br>
      which intervals the recurrence rule repeats.  The default value is<br>
      "1", meaning every second for a SECONDLY rule, every minute for a<br>
      MINUTELY rule, every hour for an HOURLY rule, every day for a<br>
      DAILY rule, every week for a WEEKLY rule, every month for a<br>
      MONTHLY rule, and every year for a YEARLY rule.  For example,<br>
      within a DAILY rule, a value of "8" means every eight days.<br>
<br>
      The BYSECOND rule part specifies a COMMA-separated list of seconds<br>
      within a minute.  Valid values are 0 to 60.  The BYMINUTE rule<br>
      part specifies a COMMA-separated list of minutes within an hour.<br>
      Valid values are 0 to 59.  The BYHOUR rule part specifies a COMMA-<br>
      separated list of hours of the day.  Valid values are 0 to 23.<br>
      The BYSECOND, BYMINUTE and BYHOUR rule parts MUST NOT be specified<br>
      when the associated "DTSTART" property has a DATE value type.<br>
      These rule parts MUST be ignored in RECUR value that violate the<br>
      above requirement (e.g., generated by applications that pre-date<br>
      this revision of iCalendar).<br>
<br>
      The BYDAY rule part specifies a COMMA-separated list of days of<br>
      the week; SU indicates Sunday; MO indicates Monday; TU indicates<br>
      Tuesday; WE indicates Wednesday; TH indicates Thursday; FR<br>
      indicates Friday; and SA indicates Saturday.<br>
<br>
      Each BYDAY value can also be preceded by a positive (+n) or<br>
      negative (-n) integer.  If present, this indicates the nth<br>
      occurrence of a specific day within the MONTHLY or YEARLY "RRULE".<br>
      <br>
      For example, within a MONTHLY rule, +1MO (or simply 1MO)<br>
      represents the first Monday within the month, whereas -1MO<br>
      represents the last Monday of the month.  The numeric value in a<br>
      BYDAY rule part with the FREQ rule part set to YEARLY corresponds<br>
      to an offset within the month when the BYMONTH rule part is<br>
      present, and corresponds to an offset within the year when the<br>
      BYWEEKNO or BYMONTH rule parts are present.  If an integer<br>
      modifier is not present, it means all days of this type within the<br>
      specified frequency.  For example, within a MONTHLY rule, MO<br>
      represents all Mondays within the month.  The BYDAY rule part MUST<br>
      NOT be specified with a numeric value when the FREQ rule part is<br>
      not set to MONTHLY or YEARLY.  Furthermore, the BYDAY rule part<br>
      MUST NOT be specified with a numeric value with the FREQ rule part<br>
      set to YEARLY when the BYWEEKNO rule part is specified.<br>
<br>
      The BYMONTHDAY rule part specifies a COMMA-separated list of days<br>
      of the month.  Valid values are 1 to 31 or -31 to -1.  For<br>
      example, -10 represents the tenth to the last day of the month.<br>
      The BYMONTHDAY rule part MUST NOT be specified when the FREQ rule<br>
      part is set to WEEKLY.<br>
<br>
      The BYYEARDAY rule part specifies a COMMA-separated list of days<br>
      of the year.  Valid values are 1 to 366 or -366 to -1.  For<br>
      example, -1 represents the last day of the year (December 31st)<br>
      and -306 represents the 306th to the last day of the year (March<br>
      1st).  The BYYEARDAY rule part MUST NOT be specified when the FREQ<br>
      rule part is set to DAILY, WEEKLY, or MONTHLY.<br>
<br>
      The BYWEEKNO rule part specifies a COMMA-separated list of<br>
      ordinals specifying weeks of the year.  Valid values are 1 to 53<br>
      or -53 to -1.  This corresponds to weeks according to week<br>
      numbering as defined in [ISO.8601.2004].  A week is defined as a<br>
      seven day period, starting on the day of the week defined to be<br>
      the week start (see WKST).  Week number one of the calendar year<br>
      is the first week that contains at least four (4) days in that<br>
      calendar year.  This rule part MUST NOT be used when the FREQ rule<br>
      part is set to anything other than YEARLY.  For example, 3<br>
      represents the third week of the year.<br>
<br>
         Note: Assuming a Monday week start, week 53 can only occur when<br>
         Thursday is January 1 or if it is a leap year and Wednesday is<br>
         January 1.<br>
<br>
      The BYMONTH rule part specifies a COMMA-separated list of months
      of the year.  Valid values are 1 to 12.<br>

      The WKST rule part specifies the day on which the workweek starts.<br>
      Valid values are MO, TU, WE, TH, FR, SA, and SU.  This is<br>
significant when a WEEKLY "RRULE" has an interval greater than 1,<br>
      and a BYDAY rule part is specified.  This is also significant when<br>
      in a YEARLY "RRULE" when a BYWEEKNO rule part is specified.  The<br>
      default value is MO.<br>
<br>
      The BYSETPOS rule part specifies a COMMA-separated list of values<br>
      that corresponds to the nth occurrence within the set of<br>
      recurrence instances specified by the rule.  BYSETPOS operates on<br>
      a set of recurrence instances in one interval of the recurrence<br>
      rule.  For example, in a WEEKLY rule, the interval would be one<br>
      week A set of recurrence instances starts at the beginning of the<br>
      interval defined by the FREQ rule part.  Valid values are 1 to 366<br>
      or -366 to -1.  It MUST only be used in conjunction with another<br>
      BYxxx rule part.  For example "the last work day of the month"<br>
      could be represented as:<br>
<br>
       FREQ=MONTHLY;BYDAY=MO,TU,WE,TH,FR;BYSETPOS=-1<br>
<br>
      Each BYSETPOS value can include a positive (+n) or negative (-n)<br>
      integer.  If present, this indicates the nth occurrence of the<br>
      specific occurrence within the set of occurrences specified by the<br>
      rule.<br>
<br>
      Recurrence rules may generate recurrence instances with an invalid<br>
      date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM<br>
      on a day where the local time is moved forward by an hour at 1:00<br>
      AM).  Such recurrence instances MUST be ignored and MUST NOT be<br>
      counted as part of the recurrence set.<br>
<br>
      Information, not contained in the rule, necessary to determine the<br>
      various recurrence instance start time and dates are derived from<br>
      the Start Time ("DTSTART") component attribute.  For example,<br>
      "FREQ=YEARLY;BYMONTH=1" doesn't specify a specific day within the<br>
      month or a time.  This information would be the same as what is<br>
      specified for "DTSTART".<br>
<br>
      BYxxx rule parts modify the recurrence in some manner.  BYxxx rule<br>
      parts for a period of time that is the same or greater than the<br>
      frequency generally reduce or limit the number of occurrences of<br>
      the recurrence generated.  For example, "FREQ=DAILY;BYMONTH=1"<br>
      reduces the number of recurrence instances from all days (if<br>
      BYMONTH rule part is not present) to all days in January.  BYxxx<br>
      rule parts for a period of time less than the frequency generally<br>
      increase or expand the number of occurrences of the recurrence.<br>
      For example, "FREQ=YEARLY;BYMONTH=1,2" increases the number of<br>
      days within the yearly recurrence set from 1 (if BYMONTH rule part<br>
      is not present) to 2.<br>
      <br>
      If multiple BYxxx rule parts are specified, then after evaluating<br>
      the specified FREQ and INTERVAL rule parts, the BYxxx rule parts<br>
      are applied to the current set of evaluated occurrences in the<br>
      following order: BYMONTH, BYWEEKNO, BYYEARDAY, BYMONTHDAY, BYDAY,<br>
      BYHOUR, BYMINUTE, BYSECOND and BYSETPOS; then COUNT and UNTIL are<br>
      evaluated.<br>
<br>
      The table below summarizes the dependency of BYxxx rule part<br>
      expand or limit behavior on the FREQ rule part value.<br>
<br>
      The term "N/A" means that the corresponding BYxxx rule part MUST<br>
      NOT be used with the corresponding FREQ value.<br>
<br>
      BYDAY has some special behavior depending on the FREQ value and<br>
      this is described in separate notes below the table.<br>
<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|..........|SECONDLY|MINUTELY|HOURLY.|DAILY..|WEEKLY|MONTHLY|YEARLY|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|BYMONTH...|Limit...|Limit...|Limit..|Limit..|Limit.|Limit..|Expand|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|BYWEEKNO..|N/A.....|N/A.....|N/A....|N/A....|N/A...|N/A....|Expand|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|BYYEARDAY.|Limit...|Limit...|Limit..|N/A....|N/A...|N/A....|Expand|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|BYMONTHDAY|Limit...|Limit...|Limit..|Limit..|N/A...|Expand.|Expand|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|BYDAY.....|Limit...|Limit...|Limit..|Limit..|Expand|Note.1.|Note.2|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|BYHOUR....|Limit...|Limit...|Limit..|Expand.|Expand|Expand.|Expand|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|BYMINUTE..|Limit...|Limit...|Expand.|Expand.|Expand|Expand.|Expand|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|BYSECOND..|Limit...|Expand..|Expand.|Expand.|Expand|Expand.|Expand|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
|BYSETPOS..|Limit...|Limit...|Limit..|Limit..|Limit.|Limit..|Limit.|<br>
+----------+--------+--------+-------+-------+------+-------+------+<br>
<br>
      Note 1:  Limit if BYMONTHDAY is present; otherwise, special expand<br>
               for MONTHLY.<br>
<br>
      Note 2:  Limit if BYYEARDAY or BYMONTHDAY is present; otherwise,<br>
               special expand for WEEKLY if BYWEEKNO present; otherwise,<br>
               special expand for MONTHLY if BYMONTH present; otherwise,<br>
               special expand for YEARLY.<br>
 * </code>
 */
public class RRule implements IProperty {

	/** Property Keyword für BYDAY */
	private static final String BYDAY_KEY = "BYDAY";
	/** Property KEyword für INTERVAL */
	private static final String INTERVAL_KEY = "INTERVAL";
	/** Die Frequenz, mit der das wiederkehrende Ereignis auftritt */
	private Frequency freq;
	/**
	 * Ein Limit für Wiederholungen oder einen Zeitpunkt, bis zu dem Wiederholungen
	 * nach den definierten Regeln auftreten.
	 */
	private RecurrencyLimit limit;
	/**
	 * Das Intervall mit dem die Wiederholungen innerhalb der gegebenen
	 * {@link Frequency} auftreten
	 */
	private int interval = 1;
	/** Die Liste der Sekunden, zu denen ein Ereignis auftreten soll */
	private Set<Integer> bySeconds = new HashSet<>();
	/** Die Liste der Minuten, zu denen ein Ereignis auftreten soll */
	private Set<Integer> byMinutes = new HashSet<>();
	/** Die Liste der Stunden, zu denen ein Ereignis auftreten soll */
	private Set<Integer> byHours = new HashSet<>();
	/** Die Liste der Wochentage, zu denen ein Ereignis auftreten soll */
	private Set<ByDay> byDays = new HashSet<>();
	/**
	 * Die Liste der Tage eines Monats, zu denen ein Ereignis auftreten soll.
	 * Negative Integer geben den nt-letzten Tag des Monats an
	 */
	private Set<Integer> byMonthDays = new HashSet<>();
	/**
	 * Die Liste der Tage eines Jahres, zu denen ein Ereignis auftreten soll.
	 * Negative Integer geben den nt-letzten Tag des Jahres an.
	 */
	private Set<Integer> byYearDays = new HashSet<>();
	/**
	 * Die Liste der Wochen eines Jahres, zu denen ein Ereignis auftreten soll.
	 * Negative Integer geben die nt-letzte Woche des Jahres an.
	 */
	private Set<Integer> byWeekNumbers = new HashSet<>();
	/**
	 * Die Liste der Monate eines Jahres, zu denen ein Ereignis auftreten soll.
	 * Negative Integer geben den nt-letzte Monat des Jahres an.
	 */
	private Set<Integer> byMonths = new HashSet<>();
	/** Die Liste der Positionen innerhalb einer angegebenen Frequenz. */
	private Set<Integer> bySetPos = new HashSet<>();
	/** Der Wochentag mit dem die Woche starten soll */
	private WeekDay weekStart = WeekDay.MONDAY;

	/**
	 * Öffentlicher Konstruktor für die Recurrence Rule mit gegebener Frequenz.
	 * 
	 * @param freq Die Frequenz, mit der das wiederkehrende Ereignis auftritt
	 */
	public RRule(Frequency freq) {
		this.freq = freq;
	}

	/**
	 * getter für die Frequenz, mit der das wiederkehrende Ereignis auftritt
	 * 
	 * @return Die Frequenz, mit der das wiederkehrende Ereignis auftritt
	 */
	public Frequency getFreq() {
		return freq;
	}

	/**
	 * setter für die Frequenz, mit der das wiederkehrende Ereignis auftritt
	 * 
	 * @param freq Die Frequenz, mit der das wiederkehrende Ereignis auftritt
	 */
	public void setFreq(Frequency freq) {
		this.freq = freq;
	}

	/**
	 * getter für das Limit für Wiederholungen
	 * 
	 * @return das Limit für Wiederholungen
	 */
	public RecurrencyLimit getLimit() {
		return limit;
	}

	/**
	 * setter für das Limit für Wiederholungen
	 * 
	 * @param limit das Limit für Wiederholungen
	 */
	public void setLimit(RecurrencyLimit limit) {
		this.limit = limit;
	}

	/**
	 * getter für das Intervall mit dem die Wiederholungen innerhalb der gegebenen
	 * Frequenz auftreten
	 * 
	 * @return das Intervall mit dem die Wiederholungen innerhalb der gegebenen
	 *         Frequenz auftreten
	 */
	public int getInterval() {
		return interval;
	}

	/**
	 * setter für das Intervall mit dem die Wiederholungen innerhalb der gegebenen
	 * Frequenz auftreten
	 * 
	 * @param interval das Intervall mit dem die Wiederholungen innerhalb der
	 *                 gegebenen Frequenz auftreten
	 */
	public void setInterval(int interval) {
		this.interval = interval;
	}

	/**
	 * getter für den Wochentag, mit dem die Woche starten soll
	 * 
	 * @return der Wochentag, mit dem die Woche starten soll
	 */
	public WeekDay getWeekStart() {
		return weekStart;
	}

	/**
	 * setter für den Wochentag mit dem die Woche starten soll
	 * 
	 * @param weekStart der Wochentag mit dem die Woche starten soll
	 */
	public void setWeekStart(WeekDay weekStart) {
		this.weekStart = weekStart;
	}

	/**
	 * getter für die Liste der Sekunden, zu denen ein Ereignis stattfinden soll.
	 * Valide Werte sind von 0 bis 59.
	 * 
	 * @return die Liste der Sekunden, zu denen ein Ereignis stattfinden soll
	 */
	public Set<Integer> getBySeconds() {
		return bySeconds;
	}

	/**
	 * getter für die Liste der Minuten, zu denen ein Ereignis stattfinden soll.
	 * Valide Werte sind von 0 bis 59.
	 * 
	 * @return die Liste der Minuten, zu denen ein Ereignis stattfinden soll
	 */
	public Set<Integer> getByMinutes() {
		return byMinutes;
	}

	/**
	 * getter für die Liste der Stunden, zu denen ein Ereignis stattfinden soll.
	 * Valide Werte sind von 0 bis 23.
	 * 
	 * @return die Liste der Stunden, zu denen ein Ereignis stattfinden soll
	 */
	public Set<Integer> getByHours() {
		return byHours;
	}

	/**
	 * getter für die Liste der Wochentage, zu denen ein Ereignis stattfinden soll
	 * 
	 * @return die Liste der Wochentage, zu denen ein Ereignis stattfinden soll
	 */
	public Set<ByDay> getByDays() {
		return byDays;
	}

	/**
	 * getter für die Liste der Tage im Monat, zu denen ein Ereignis stattfinden
	 * soll. Valide Werte sind zwischen -31 und -1 sowie zwischen 1 und 31. Negative
	 * Werte geben den nt-letzten Wert des Monats an.
	 * 
	 * @return die Liste der Tage im Monat, zu denen ein Ereignis stattfinden soll
	 */
	public Set<Integer> getByMonthDays() {
		return byMonthDays;
	}

	/**
	 * getter für die Liste der Tage im Jahr, zu denen ein Ereignis stattfinden
	 * soll. Valide Werte sind zwischen -366 und -1 sowie 1 und 366. Negative Werte
	 * geben den nt-letzten Tag des Jahres an.
	 * 
	 * @return die Liste der Tage im Jahr, zu denen ein Ereignis stattfinden soll
	 */
	public Set<Integer> getByYearDays() {
		return byYearDays;
	}

	/**
	 * getter für die Liste der Wochen eines Jahres, in denen ein Ereignis
	 * stattfinden soll.<br>
	 * The BYWEEKNO rule part specifies a COMMA-separated list of<br>
	 * ordinals specifying weeks of the year. Valid values are 1 to 53<br>
	 * or -53 to -1.
	 * 
	 * @return die Liste der Wochen eines Jahres, in denen ein Ereignis stattfinden
	 *         soll.
	 */
	public Set<Integer> getByWeekNumbers() {
		return byWeekNumbers;
	}

	/**
	 * getter für die Liste der Monate, in denen ein Ereignis stattfinden soll.
	 * Valid values are 1 to 12.
	 * 
	 * @return die Liste der Monate, in denen ein Ereignis stattfinden soll.
	 */
	public Set<Integer> getByMonths() {
		return byMonths;
	}

	/**
	 * getter für die Liste der Einschränkungen der Vorkommen innerhalb einer
	 * angegebenen Frequenz. Diese Werte schränken abhängig von der Frequenz und der
	 * gegebenen Regel das nte Auftreten der aus der Regel auftretenden Ereignisse
	 * innerhalb der gegebenen Frequenz an. Negative Werte geben das n-letzte
	 * Vorkommen an.<br>
	 * Valid values are 1 to 366 or -366 to -1.<br>
	 * Beispiel: <code>FREQ=MONTHLY;BYDAY=MO,TU,WE,TH,FR;BYSETPOS=-1</code> als
	 * Regel gibt monatlich wiederholende Termine an Werktagen an. Durch BYSETPOS
	 * werden diese Termine auf den letzten Werktag eines Monats eingeschränkt.
	 * 
	 * @return die Liste der Einschränkungen der Vorkommen innerhalb einer
	 *         angegebenen Frequenz.
	 */
	public Set<Integer> getBySetPos() {
		return bySetPos;
	}

	@Override
	public String getKey() {
		return PropertyKeys.RRULE.name();
	}

	@Override
	public String getValue() {
		StringBuilder sb = new StringBuilder();
		append(sb, "FREQ", this.freq.toString());
		if (this.interval != 1) {
			sb.append(";");
			append(sb, INTERVAL_KEY, String.valueOf(interval));
		}
		if (this.limit != null) {
			sb.append(";");
			this.limit.append(sb);
		}
		append(sb, "BYSECOND", this.bySeconds);
		append(sb, "BYMINUTE", this.byMinutes);
		append(sb, "BYHOUR", this.byHours);
		if (!this.byDays.isEmpty()) {
			sb.append(";");
			append(sb, BYDAY_KEY, this.byDays.stream().sorted().map(ByDay::toString));
		}
		append(sb, "BYMONTHDAY", this.byMonthDays);
		append(sb, "BYYEARDAY", this.byYearDays);
		append(sb, "BYWEEKNO", this.byWeekNumbers);
		append(sb, "BYMONTH", this.byMonths);
		append(sb, "BYSETPOS", this.bySetPos);
		if (this.weekStart != WeekDay.MONDAY) {
			sb.append(";");
			append(sb, "WKST", this.weekStart.getStringRep());
		}
		return sb.toString();
	}

	/**
	 * Hilfsmethode: Fügt einem StringBuilder den key und das zugehörige Set von
	 * Integern als sortierte, kommagetrennte Werte hinzu nach dem Muster
	 * <code>;KEY=LIST</code>. Greift dazu auf
	 * {@link #append(StringBuilder, String, Stream)} zurück. Ist das gegebene Set
	 * nicht leer, wird ein führendes Semikolon zugefügt.
	 * 
	 * @param sb   der Stringbuilder
	 * @param key  der Schlüsselwert des Key-Value-Paars
	 * @param ints das Set mit Integern, welches den Value des Key-Value-Paars
	 *             darstellen
	 */
	private static void append(StringBuilder sb, String key, Set<Integer> ints) {
		if (!ints.isEmpty()) {
			sb.append(";");
			append(sb, key, ints.stream().sorted().map(String::valueOf));
		}
	}

	/**
	 * Hilfsmethode: Fügt einem StringBuilder den Key und die kommagetrennten Werte
	 * des Streams nach dem Muster <code>KEY=VALUE1,VALUE2...</code> hinzu. Greift
	 * auf {@link #append(StringBuilder, String, String)} zurück
	 * 
	 * @param sb     der StringBuilder
	 * @param key    der Schlüsselwert des Key-Value-Paars
	 * @param stream ein Stream mit den Werten des Key-Value-Paars
	 */
	private static void append(StringBuilder sb, String key, Stream<String> stream) {
		append(sb, key, stream.collect(Collectors.joining(",")));
	}

	/**
	 * Hilfsmethode: Fügt einem StringBuilder den Key und den Value nach dem Muster
	 * <code>KEY=VALUE</code> hinzu.
	 * 
	 * @param sb
	 * @param key
	 * @param value
	 */
	private static void append(StringBuilder sb, String key, String value) {
		sb.append(key);
		sb.append("=");
		sb.append(value);
	}

	@Override
	public void serialize(StringBuffer sb) {
		sb.append(getKey());
		sb.append(COLON_CHAR);
		sb.append(getValue());
		sb.append(VCalendar.LINEBREAK);
	}

	/**
	 * Erstellt ein RRule aus einem gegebenen PropertyString wie er in einem .ics
	 * geschrieben steht
	 * 
	 * @param pProp das Property als String
	 * @return das geparste RRule Objekt welches diesen String repräsentiert
	 */
	public static RRule fromString(String pProp) {
		String prop = pProp;
		if (prop.endsWith(VCalendar.LINEBREAK)) {
			prop = pProp.replace(VCalendar.LINEBREAK, "");
		}
		String rule = prop.substring(prop.indexOf(COLON_CHAR) + 1);
		String[] rules = rule.split(";");
		int idxOfComp = -1;
		Map<String, String> keyValueMap = new HashMap<>();
		for (String s : rules) {
			idxOfComp = s.indexOf('=');
			if (idxOfComp != -1) {
				keyValueMap.put(s.substring(0, idxOfComp), s.substring(idxOfComp + 1));
			}
		}
		Frequency frequency = Frequency.valueOf(keyValueMap.get("FREQ"));
		RRule r = new RRule(frequency);
		if (keyValueMap.containsKey(INTERVAL_KEY)) {
			r.setInterval(Integer.valueOf(keyValueMap.get(INTERVAL_KEY)));
		}
		if (keyValueMap.containsKey("COUNT")) {
			r.setLimit(new RecurrencyLimit(Integer.valueOf(keyValueMap.get("COUNT"))));
		}
		if (keyValueMap.containsKey("UNTIL")) {
			r.setLimit(new RecurrencyLimit(DateTimeUtil.parseCalDav(keyValueMap.get("UNTIL"))));
		}
		addIntegersToSetIfKeyContained("BYSECOND", keyValueMap, r.getBySeconds());
		addIntegersToSetIfKeyContained("BYMINUTE", keyValueMap, r.getByMinutes());
		addIntegersToSetIfKeyContained("BYHOUR", keyValueMap, r.getByHours());
		if (keyValueMap.containsKey(BYDAY_KEY)) {
			String[] values = keyValueMap.get(BYDAY_KEY).split(",");
			r.getByDays().addAll(Arrays.asList(values).stream().map(ByDay::fromString).toList());
		}

		addIntegersToSetIfKeyContained("BYMONTHDAY", keyValueMap, r.getByMonthDays());
		addIntegersToSetIfKeyContained("BYYEARDAY", keyValueMap, r.getByYearDays());
		addIntegersToSetIfKeyContained("BYWEEKNO", keyValueMap, r.getByWeekNumbers());
		addIntegersToSetIfKeyContained("BYMONTH", keyValueMap, r.getByMonths());
		addIntegersToSetIfKeyContained("BYSETPOS", keyValueMap, r.getBySetPos());
		if (keyValueMap.containsKey("WKST")) {
			r.setWeekStart(WeekDay.fromStringRep(keyValueMap.get("WKST")));
		}
		return r;
	}

	/**
	 * Hilfsmethode, welche die den zum Key passenden Value der KeyValueMap zu einem
	 * Set zufügt. Erwartet wird eine kommagetrennte Liste von Integern. Prüft ob
	 * die Map den Key enthält
	 * 
	 * @param key         der Key für die KeyValueMap
	 * @param keyValueMap die KeyValueMap, welche dem Key zugeordnete Zeichenkette
	 *                    mit kommagetrennten Integern enthält
	 * @param set         das set, dem die Integer zugefügt werden sollen
	 */
	private static void addIntegersToSetIfKeyContained(String key, Map<String, String> keyValueMap, Set<Integer> set) {
		if (keyValueMap.containsKey(key)) {
			String valueStr = keyValueMap.get(key);
			String[] values = valueStr.split(",");
			set.addAll(Arrays.asList(values).stream().map(Integer::valueOf).toList());
		}
	}

	/**
	 * Gibt das Maximale Datum wieder, wenn dieser Regelsatz mit dem gegebenen
	 * Startpunkt berechnet wird.
	 * 
	 * @param dtStart der Startzeitpunkt
	 * @return das maximale Datum entsprechend der hier definierten Regeln.
	 */
	public Instant getMaxInstant(Instant dtStart) {
		if (this.limit == null || this.limit.getUntil() != null) {
			return Instant.MAX;// cutoff, Recurrence Rules auswerten nicht funktional.
		}
		return this.limit.getUntil();
	}
}
